% (The MIT License)
%
% Copyright (c) 2022-2023 Yegor Bugayenko
%
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the 'Software'), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
%
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

\documentclass{article}
\usepackage{../ppa}
\newcommand*\thetitle{Formal Grammar}
\newcommand*\thesubtitle{CSG, CFG, Parse Tree, Ambiguity, Non-Determinism}
\begin{document}

\plush{\lnTitlePage{1}{10}{rsoPqA1CYmE}}

\pptToc

\plush{\pptThought{I promise, there will be no more \emph{formalism} than it's necessary!}}

\plush{\pptChapter{Notation}}

By the way, if a language is simple, it's possible to do it without a grammar, for example (we just split the text by a space):
\begin{ffcode}
PRINT 42
PRINT 256
PRINT 0
\end{ffcode}
\plush{}

A practical example: I have a project \textbf{Xembly},
which is using ANTLR4 for parsing its own language:
\begin{ffcode}
XPATH "/car/price";
SET "$2000";
ATTR "time", "2023/02/01";
\end{ffcode}
However, I have a task in the backlog: get rid of the grammar and
use string manipulations instead, because it's faster.
\plush{}

A \emph{grammar} is a finite set of formal rules for generating~(!) syntactically correct sentences. Pay attention to the word ``formal.'' A grammar may be informal, if the rules are informal. For example:

\emph{``Commands go one after another sometimes with arguments''}

This is a rule, but it is not formal and may not be understood by a computer.
\plush{}

Assume, we want to create a new programming language (very similar to Basic), which will allow us to write programs that look like this:
\begin{ffcode}
10 PRINT "What is your name?"
20 INPUT X
30 PRINT "Hello,", X
\end{ffcode}
It's impossible (or very hard) to parse this program by splitting strings, for example, because of the possible commas inside the \texttt{"Hello,"} string.
\plush{}

A formal \emph{grammar} $G$, according to Noam Chomsky (1956), is a tuple $\langle N, T, P, S\rangle$, where:
\begin{itemize}
  \item $N = \{ P_\texttt{rogram}, L_\texttt{ine}, N_\texttt{umber},
    C_\texttt{ommand}, A_\texttt{rgument}, \dots \}$ (\emph{non-terminals} or \emph{variables})
  \item $T = \{ \texttt{10}, \texttt{20},
    \texttt{PRINT}, \texttt{X}, \texttt{,}, \texttt{"Hello"}, \dots \}$ (\emph{terminals} or \emph{alphabet})
  \item $P = \{ \dots \}$ (\emph{production rules})
  \item $S \in N$ (\emph{start symbol})
\end{itemize}

By the way, $N \cap T = \emptyset$.
\plush{}

A \emph{language} that can be built by $G$ is denoted as $\bm{L}(G)$: set of all strings that can be generated by $G$.
\plush{}

A \emph{production rule} specifies a replacement of its \emph{left-hand side} with its \emph{right-hand side}, for example:
\begin{enumerate}
    \item[1.] $L_\texttt{ine} \; \to N_\texttt{umber} \; \texttt{INPUT} \; A_\texttt{rgument}$
    \item[2.] $N_\texttt{umber} \; \to \texttt{10}$
    \item[3.] $N_\texttt{umber} \; \to \texttt{20}$
\end{enumerate}

Formally, a production rule is (using \emph{Kleene star}, by Stephen Kleene):
\begin{gather*}
(T \cup N)^* n (T \cup N)^* \to (T \cup N)^* \quad n \in N \\
V^* n V^* \to V^* \quad V = (T \cup N) \\
\end{gather*}
Each left-hand side must contain at least one non-terminal symbol.
\plush{}

Grammars are said to be \emph{equivalent} if they produce the same language.
\plush{}

\plush{\pptChapter{Chomsky Hierarchy}}

There are four types in Chomsky Hierarchy of grammars:
\begin{enumerate}
  \item[Type-0:] Unrestricted grammars
  \item[Type-1:] Context-sensitive grammars
  \item[Type-2:] Context-free grammars
  \item[Type-3:] Regular grammars
\end{enumerate}
\plush{}

\pptSection[Unrestricted]{Type-0: Unrestricted Grammar}

The only restriction is that $\alpha$ is not empty (not \(\epsilon\)) in each rule:
\begin{equation*}
\alpha \to \beta \quad \alpha, \beta \in N \cup T
\end{equation*}

For every unrestricted grammar $G$ there exists some Turing machine capable of recognizing $\bm{L}(G)$ and vice versa.
\plush{}

The decision problem of whether a given string $s$ can be generated by a given unrestricted grammar is equivalent to the problem of whether it can be accepted by the \emph{Turing machine} equivalent to the grammar. The latter problem is called the \emph{Halting problem} and is undecidable.
\plush{}

\pptSection[CSG]{Type-1: Context-Sensitive Grammar}

A \emph{context-sensitive grammar} (CSG) are ``non-erasing'' grammars. A grammar is \emph{noncontracting} (or \emph{monotonic}) if all of its production rules are of the form \(\alpha \to \beta\) where the length of \(\alpha\) is less than or equal to that of \(\beta\).

Some textbooks define CSGs as non-contracting, although this is not how Noam Chomsky defined them in 1959.

A canonical example is \(\{ a^nb^nc^n : n \geq 1 \}\).
\plush{}

\pptSection[CFG]{Type-2: Context Free Grammar}

A \emph{context-free grammar} (CFG) is a grammar in which the left-hand side of each production rule consists of only a single non-terminal symbol, for example:
\begin{enumerate}
\setlength\itemsep{0pt}
    \item[$p_1$:] $P_\texttt{rogram} \to P_\texttt{rogram} \; L_\texttt{ine}$
    \item[$p_2$:] $P_\texttt{rogram} \to \epsilon$
    \item[$p_3$:] $L_\texttt{ine} \to I_\texttt{nteger} \; C_\texttt{ommand} \; T_\texttt{ail}$
    \item[$p_4$:] $T_\texttt{ail} \to T_\texttt{ail} \; A_\texttt{rgument}$
    \item[$p_5$:] $T_\texttt{ail} \to \epsilon$
    \item[$p_6$:] $I_\texttt{nteger} \to \texttt{10}$
    \item[$p_7$:] $I_\texttt{nteger} \to \texttt{20}$
\end{enumerate}
\plush{}

Derivation process may be described using $\xRightarrow[p_i]{}$ notation:
\begin{equation*}
\begin{split}
P &\xRightarrow[p_1]{} \bm{P} \; \bm{L} \\
  &\xRightarrow[p_3]{} P \; \bm{I} \; \bm{C} \; \bm{T} \\
  &\xRightarrow[p_8]{} P \; \textbf{\texttt{30}} \; C \; T \\
  &\xRightarrow[p_?]{} P \; \texttt{30} \; \textbf{\texttt{PRINT}} \; T \\
  &\xRightarrow[p_1]{} \bm{P} \; \bm{L} \; \texttt{30} \; \texttt{PRINT} \; T \\
  &\xRightarrow[p_?]{} \dots \\
\end{split}
\end{equation*}
\plush{}

We can say that ``$G$ derives in zero or more steps'': $\xRightarrow[G]{*}$ (it is \emph{reflexive transitive closure} of $\xRightarrow[G]{}$). For example:
\begin{equation*}
\begin{split}
P &\xRightarrow[G]{*} P \; L \; \texttt{30} \; \texttt{PRINT} \; T \\
\end{split}
\end{equation*}
\plush{}

Languages generated by context-free grammars are known as \emph{context-free languages} (CFL).

Not all languages can be generated by CFGs.
\plush{}

The \emph{language equality} question (do two given context-free grammars generate the same language?) is undecidable.

The \emph{language inclusion} question is also undecidable: Given two CFGs, can the first one generate all strings that the second one can generate?
\plush{}

The \emph{emptiness problem} (whether the grammar generates any terminal strings at all), is undecidable for context-sensitive grammars, but decidable for CFGs.
\plush{}

\emph{Leftmost derivation}: always expands leftmost non-terminal.

There are \emph{left recursive} CFGs: when non-terminals stay always on the left side of the right-side hand of the rule. Similarly, there are \emph{right recursive} CFGs.
\plush{}

\pptSection[Regular]{Type-3: Regular Grammar}

In a \emph{regular grammar} all production rules have at most one non-terminal symbol in the rightmost or leftmost position in the rule
($A$ and $B$ are non-terminals and $a$ is a string of terminals):
\begin{equation*}
\begin{split}
A &\to a \\
A &\to a \; B \quad \text{(\emph{right-linear grammar})} \\
A &\to B \; a \quad \text{(\emph{left-linear grammar})} \\
A &\to \epsilon \\
\end{split}
\end{equation*}
\plush{}

Left-linear grammar is just another name for left-regular grammar (the same for right-).
\plush{}

Some textbooks and articles disallow empty rules (with \(\epsilon\)).
\plush{}

A regular grammar generates exactly the language a nondeterministic finite automaton accepts.
\plush{}

\plush{\pptChapter{Parse Tree}}

A \emph{parse tree} (parsing tree, derivation tree, concrete syntax tree) is an ordered, rooted tree that represents the syntactic structure of a string according to some CFG.

\begin{tikzpicture}[graph]
\node (root) {$P$};
\node[below left=1cm of root] (prog) {$P$};
\draw (root) -> (prog);
\node[below right=1cm of root] (third) {$L$};
\draw (root) -> (third);
\node[below left=1cm of third] (int) {$N$};
\draw (third) -> (int);
\node[below=1cm of third] (cmd) {$C$};
\draw (third) -> (cmd);
\node[below right=1cm of third] (tail) {$A$};
\draw (third) -> (tail);
\node[below=1cm of int] (i30) {\texttt{30}};
\draw (int) -> (i30);
\end{tikzpicture}
\plush{}

\plush{\pptChapter{Ambiguity}}

\plick{An \emph{ambiguous grammar} is a CFG for which there exists a string that can have more than one leftmost derivation or parse tree. For example, this grammar:
\begin{equation*}
\begin{split}
A &\to B\;t \; \vert \; t\;B \\
B &\to t \\
\end{split}
\end{equation*}}

\plush{May be parsed as two different trees: \\
\begin{tikzpicture}[graph]
\node (a1) {$A$};
\node[below left=1cm of a1] (b1) {$B$};
\draw (a1) -> (b1);
\node[below right=1cm of a1] (t1) {$t$};
\draw (a1) -> (t1);
\node[below=1cm of b1] (t21) {$t$};
\draw (b1) -> (t21);
%
\node [right=5cm of a1] (a2) {$A$};
\node[below right=1cm of a2] (b2) {$B$};
\draw (a2) -> (b2);
\node[below left=1cm of a2] (t2) {$t$};
\draw (a2) -> (t2);
\node[below=1cm of b2] (t22) {$t$};
\draw (b2) -> (t22);
\end{tikzpicture}}

\plush{\pptChapter{Non-determinism}}

\plick{Non-deterministic CFG:
\begin{equation*}
\begin{split}
A &\to B \; x \\
A &\to B \; y \\
A &\to B \; z \\
\end{split}
\end{equation*}
\emph{Backtracking} in a parser is required in order to parse this grammar.}

\plush{By using \emph{left factoring} it is possible to remove non-determinism:
\begin{equation*}
\begin{split}
A &\to B \; C \\
C &\to x \; \vert \; y \; \vert \; z \\
\end{split}
\end{equation*}}

\end{document}
